use std::{sync::Arc, time::Duration};

use crate::{config::CONFIG, state::InnerAppState};
use aide::{axum::ApiRouter, openapi::OpenApi};
use axum::Extension;

use cli::CLI;
use tokio::signal;
use tower_http::{compression::CompressionLayer, timeout::TimeoutLayer};
use tracing::info;
use tracing_subscriber::{fmt::SubscriberBuilder, EnvFilter};

/// this is where the api is defined.
/// subservices are split into their own modules
pub mod api;
/// command line app
pub mod cli;
/// generate and read config file
pub mod config;
/// database stuff
pub mod db;
/// serve docs
mod docs;
/// extractors for aide
pub mod extractors;
/// serves the frontend
pub mod frontend;
/// middleware for checking user authentication
/// and powerlevel
pub mod middleware;
/// used for hashing passwords
pub mod pass;
/// autogenerated schema, do not change,
/// let diesel handle it
pub mod schema;
/// state for the app
pub mod state;

/// tests for CI/CD,
/// these are not meant for ci/cd.
/// don't worry if they fail locally.
#[cfg(test)]
mod tests;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // enable tracing
    SubscriberBuilder::default()
        .pretty()
        .with_env_filter(
            EnvFilter::builder()
                .with_default_directive(CONFIG.logging.loglevel.into())
                .from_env_lossy(),
        )
        .init();

    // run db migrations before being able to change anything
    db::run_migrations()?;

    match CLI.command.clone() {
        cli::Commands::Run => {
            start_server().await?;
        }
        cli::Commands::User {
            subcommand,
            username,
        } => match subcommand {
            cli::UserSubcommands::ChangePassword { new_password } => {
                cli::user::change_password(&username, &new_password)?
            }
            cli::UserSubcommands::SetPowerLevel { powerlevel } => {
                cli::user::change_powerlevel(&username, &powerlevel)?
            }
        },
    }

    Ok(())
}

async fn generate_server() -> Result<axum::Router, Box<dyn std::error::Error>> {
    // generate openapi docs
    aide::gen::on_error(|error| panic!("{}", error));
    aide::gen::extract_schemas(true);
    let mut api = OpenApi::default(); // used to edit api docs

    // tests that need db call this, but not in  main
    #[cfg(test)]
    db::run_migrations()?;

    // generate state
    let state = Arc::new(InnerAppState {
        pool: db::get_pool().await?,
    });

    // put together routes
    Ok(ApiRouter::new()
        .nest_api_service("/api", api::routes(state.clone()))
        .nest_api_service("/docs", docs::docs_routes(state.clone()))
        .nest_api_service("/", frontend::routes())
        .finish_api_with(&mut api, docs::add_api_docs)
        .layer(Extension(Arc::new(api)))
        .layer(TimeoutLayer::new(Duration::from_secs(20)))
        .layer(
            CompressionLayer::new()
                .gzip(true)
                // we have as much cpu as we want really
                // since rust is kinda overkill anyway
                .quality(tower_http::CompressionLevel::Best),
        )
        .with_state(state))
}

/// start the actual web server
async fn start_server() -> Result<(), Box<dyn std::error::Error>> {
    let app = generate_server().await?;

    let addr = config::CONFIG
        .server
        .socket
        .parse::<std::net::SocketAddr>()?;
    info!("starting server on address: {}", addr);

    // panic or unwrap is ok until here
    // we would like the server to abort immediately
    // rather than be misconfigured
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .with_graceful_shutdown(shutdown_signal())
        .await?;

    Ok(())
}

/// provide a graceful shutdown signal for the server
async fn shutdown_signal() {
    let ctrl_c = async {
        signal::ctrl_c()
            .await
            .expect("failed to install Ctrl+C handler");
    };

    #[cfg(unix)]
    let terminate = async {
        signal::unix::signal(signal::unix::SignalKind::terminate())
            .expect("failed to install signal handler")
            .recv()
            .await;
    };

    #[cfg(not(unix))]
    let terminate = std::future::pending::<()>();

    tokio::select! {
        _ = ctrl_c => {},
        _ = terminate => {},
    }

    info!("received signal to terminate, starting graceful shutdown")
}
