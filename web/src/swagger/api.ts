/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * intract
 * intract is an rss reader for the modern web
 *
 * OpenAPI spec version: 0.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "http://localhost:3000".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * data used to log a user in
 * @export
 * @interface LoginData
 */
export interface LoginData {
    /**
     * description for a session. clients can set this to whatever they want, or let the user set it themselves.  something like time and client name can be useful. just make sure they are human readable!
     * @type {any}
     * @memberof LoginData
     */
    description?: any;
    /**
     * password for the user you want to log in
     * @type {any}
     * @memberof LoginData
     */
    password: any;
    /**
     * username for the account you want to log in
     * @type {any}
     * @memberof LoginData
     */
    username: any;
}
/**
 * 
 * @export
 */
export type Powerlevel = any
/**
 * data needed to sign up for an account
 * @export
 * @interface RegisterData
 */
export interface RegisterData {
    /**
     * give a bit of context as to why you want to join. links to social media and a little bit about youself can provide good reasons for an admin to let you join.
     * @type {any}
     * @memberof RegisterData
     */
    joinReason?: any;
    /**
     * password to use. it has to be at least as long as the password set in the server config.
     * @type {any}
     * @memberof RegisterData
     */
    password: any;
    /**
     * username to use, you can change this later. this is used for logging in.
     * @type {any}
     * @memberof RegisterData
     */
    username: any;
}
/**
 * 
 * @export
 * @interface ServerInfo
 */
export interface ServerInfo {
    /**
     * lowest length a password can be
     * @type {any}
     * @memberof ServerInfo
     */
    minPasswordLength: any;
    /**
     * the url the server is running on, something like `https://example.com`
     * @type {any}
     * @memberof ServerInfo
     */
    url: any;
}
/**
 * 
 * @export
 * @interface Session
 */
export interface Session {
    /**
     * set during login.  description for a session. clients can set this to whatever they want, or let the user set it themselves.  something like time and client name can be useful. just make sure they are human readable!
     * @type {any}
     * @memberof Session
     */
    description?: any;
    /**
     * timestamp when the token expires. it will not be usable anymore once the expiry date has passed.
     * @type {SystemTime}
     * @memberof Session
     */
    expiresAt: SystemTime;
    /**
     * session secret! put this in the header called 'Key'
     * @type {any}
     * @memberof Session
     */
    secret: any;
    /**
     * unique id for a user, uses uuid v7. this is based on time and makes ordering them in the databse faster.
     * @type {any}
     * @memberof Session
     */
    userId: any;
}
/**
 * 
 * @export
 * @interface SystemTime
 */
export interface SystemTime {
    /**
     * 
     * @type {any}
     * @memberof SystemTime
     */
    nanosSinceEpoch: any;
    /**
     * 
     * @type {any}
     * @memberof SystemTime
     */
    secsSinceEpoch: any;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * bio of this user
     * @type {any}
     * @memberof User
     */
    bio?: any;
    /**
     * should be more prominently featured than username
     * @type {any}
     * @memberof User
     */
    displayName?: any;
    /**
     * unique id for a user, uses uuid v7. this is based on time and makes ordering them in the databse faster.
     * @type {any}
     * @memberof User
     */
    id: any;
    /**
     * how much this user is allowed to do
     * @type {Powerlevel}
     * @memberof User
     */
    powerlevel: Powerlevel;
    /**
     * pronouns of this user, can be set back to none
     * @type {any}
     * @memberof User
     */
    pronoun?: any;
    /**
     * username for logging in
     * @type {any}
     * @memberof User
     */
    username: any;
}
/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * provide username and password to get a session token. keep it safe!
         * @summary log in
         * @param {LoginData} body data used to log a user in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling login.');
            }
            const localVarPath = `/api/v1/account/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"LoginData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * use this if you want a new account. it tries to create a new user with the password + username you gave. by default unapproved users have no permission to access any locked api routesor the login route
         * @summary apply for account
         * @param {RegisterData} body data needed to sign up for an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegisterData, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling register.');
            }
            const localVarPath = `/api/v1/account/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"RegisterData" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * tells you information about your account. one useful thing you can do with this is checking if you are logged in.
         * @summary who am i???
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/authorized/account/whoami`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("Key")
					: configuration.apiKey;
                localVarHeaderParameter["Key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * provide username and password to get a session token. keep it safe!
         * @summary log in
         * @param {LoginData} body data used to log a user in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Session> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).login(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * use this if you want a new account. it tries to create a new user with the password + username you gave. by default unapproved users have no permission to access any locked api routesor the login route
         * @summary apply for account
         * @param {RegisterData} body data needed to sign up for an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegisterData, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).register(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * tells you information about your account. one useful thing you can do with this is checking if you are logged in.
         * @summary who am i???
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).whoami(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * provide username and password to get a session token. keep it safe!
         * @summary log in
         * @param {LoginData} body data used to log a user in
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(body: LoginData, options?: any) {
            return AccountApiFp(configuration).login(body, options)(fetch, basePath);
        },
        /**
         * use this if you want a new account. it tries to create a new user with the password + username you gave. by default unapproved users have no permission to access any locked api routesor the login route
         * @summary apply for account
         * @param {RegisterData} body data needed to sign up for an account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(body: RegisterData, options?: any) {
            return AccountApiFp(configuration).register(body, options)(fetch, basePath);
        },
        /**
         * tells you information about your account. one useful thing you can do with this is checking if you are logged in.
         * @summary who am i???
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        whoami(options?: any) {
            return AccountApiFp(configuration).whoami(options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * provide username and password to get a session token. keep it safe!
     * @summary log in
     * @param {LoginData} body data used to log a user in
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public login(body: LoginData, options?: any) {
        return AccountApiFp(this.configuration).login(body, options)(this.fetch, this.basePath);
    }

    /**
     * use this if you want a new account. it tries to create a new user with the password + username you gave. by default unapproved users have no permission to access any locked api routesor the login route
     * @summary apply for account
     * @param {RegisterData} body data needed to sign up for an account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public register(body: RegisterData, options?: any) {
        return AccountApiFp(this.configuration).register(body, options)(this.fetch, this.basePath);
    }

    /**
     * tells you information about your account. one useful thing you can do with this is checking if you are logged in.
     * @summary who am i???
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public whoami(options?: any) {
        return AccountApiFp(this.configuration).whoami(options)(this.fetch, this.basePath);
    }

}
/**
 * DocsApi - fetch parameter creator
 * @export
 */
export const DocsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * show the redoc openapi viewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docsRedocGet(options: any = {}): FetchArgs {
            const localVarPath = `/docs/redoc`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocsApi - functional programming interface
 * @export
 */
export const DocsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * show the redoc openapi viewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docsRedocGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DocsApiFetchParamCreator(configuration).docsRedocGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocsApi - factory interface
 * @export
 */
export const DocsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * show the redoc openapi viewer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docsRedocGet(options?: any) {
            return DocsApiFp(configuration).docsRedocGet(options)(fetch, basePath);
        },
    };
};

/**
 * DocsApi - object-oriented interface
 * @export
 * @class DocsApi
 * @extends {BaseAPI}
 */
export class DocsApi extends BaseAPI {
    /**
     * show the redoc openapi viewer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocsApi
     */
    public docsRedocGet(options?: any) {
        return DocsApiFp(this.configuration).docsRedocGet(options)(this.fetch, this.basePath);
    }

}
/**
 * ServerApi - fetch parameter creator
 * @export
 */
export const ServerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * this is for getting information about the server. instances will be configured differently and these are the configurable parameters that are important for clients.
         * @summary server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/server/info`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerApi - functional programming interface
 * @export
 */
export const ServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * this is for getting information about the server. instances will be configured differently and these are the configurable parameters that are important for clients.
         * @summary server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ServerInfo> {
            const localVarFetchArgs = ServerApiFetchParamCreator(configuration).serverInfo(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ServerApi - factory interface
 * @export
 */
export const ServerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * this is for getting information about the server. instances will be configured differently and these are the configurable parameters that are important for clients.
         * @summary server info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serverInfo(options?: any) {
            return ServerApiFp(configuration).serverInfo(options)(fetch, basePath);
        },
    };
};

/**
 * ServerApi - object-oriented interface
 * @export
 * @class ServerApi
 * @extends {BaseAPI}
 */
export class ServerApi extends BaseAPI {
    /**
     * this is for getting information about the server. instances will be configured differently and these are the configurable parameters that are important for clients.
     * @summary server info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerApi
     */
    public serverInfo(options?: any) {
        return ServerApiFp(this.configuration).serverInfo(options)(this.fetch, this.basePath);
    }

}
